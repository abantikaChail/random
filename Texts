// ===== Stacked RAG bar chart (replace the old function with this) =====
let stackedChart = null;

function renderStackedBar(stats) {
  stats = stats || [];
  const labels = stats.map(s => s.leader);
  const greens = stats.map(s => s.g || 0);
  const ambers = stats.map(s => s.a || 0);
  const reds   = stats.map(s => s.r || 0);

  const canvas = document.getElementById('stackedBarChart');
  if (!canvas) return;

  // ======= CONTROL HEIGHT HERE =======
  const TARGET_HEIGHT_PX = 90;           // <-- change this to 70 / 100 / 120 etc.
  // Optionally: dynamic height based on number of labels (uncomment if desired)
  // const TARGET_HEIGHT_PX = Math.min(140, 40 + labels.length * 14);

  // Force the canvas element to the target height (both attribute and CSS)
  canvas.height = TARGET_HEIGHT_PX;              // sets internal drawing buffer height
  canvas.style.height = TARGET_HEIGHT_PX + 'px'; // sets CSS layout height

  // If there's an existing chart, destroy it before creating a new one
  if (stackedChart) {
    try { stackedChart.destroy(); } catch(e){ /* ignore */ }
    stackedChart = null;
  }

  // Colors from CSS variables to keep visual consistency
  const colG = getVar('--success') || '#35d07f';
  const colA = getVar('--warning') || '#ffb648';
  const colR = getVar('--danger')  || '#ff5c7a';

  // Build the chart
  const ctx = canvas.getContext('2d');
  stackedChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        { label: 'Green (G)',  data: greens, backgroundColor: colG, stack: 'stack1' },
        { label: 'Amber (A)',  data: ambers, backgroundColor: colA, stack: 'stack1' },
        { label: 'Red (R)',    data: reds,   backgroundColor: colR, stack: 'stack1' }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false, // IMPORTANT: tells Chart.js to obey canvas height
      scales: {
        x: {
          stacked: true,
          ticks: { color: getVar('--text') || undefined, maxRotation: 45, minRotation: 0 },
          grid: { display: false }
        },
        y: {
          stacked: true,
          beginAtZero: true,
          ticks: { color: getVar('--text') || undefined, precision: 0 }
        }
      },
      plugins: {
        legend: { position:'top', labels: { color: getVar('--text') || undefined } },
        tooltip: {
          callbacks: {
            label: function(ctx) { return (ctx.dataset.label || '') + ': ' + (ctx.raw || 0); },
            footer: function(items) {
              if (!items || !items.length) return '';
              const i = items[0].dataIndex;
              const total = (greens[i]||0) + (ambers[i]||0) + (reds[i]||0);
              return 'Total: ' + total;
            }
          },
          bodyColor: getVar('--text') || undefined,
          titleColor: getVar('--text') || undefined,
          footerColor: getVar('--muted') || undefined
        }
      },
      interaction: { mode: 'index', intersect: false }
    }
  });
}
