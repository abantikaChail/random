// ===== Stacked RAG bar chart =====
let stackedChart = null;

/**
 * Render stacked bar chart for a given leaderStats array (each item has leader, g, a, r).
 * Expects `stats` to be an array of { leader, g, a, r, ... }.
 */
function renderStackedBar(stats) {
  // Defensive: ensure stats is array
  stats = stats || [];

  // Prepare labels and three datasets (G, A, R)
  const labels = stats.map(s => s.leader);
  const greens = stats.map(s => s.g || 0);
  const ambers = stats.map(s => s.a || 0);
  const reds   = stats.map(s => s.r || 0);

  // Destroy previous chart if present
  const ctx = document.getElementById('stackedBarChart');
  if (!ctx) return;
  if (stackedChart) stackedChart.destroy();

  // Use CSS variables for colors so appearance stays consistent
  const colG = getVar('--success') || '#35d07f';
  const colA = getVar('--warning') || '#ffb648';
  const colR = getVar('--danger')  || '#ff5c7a';

  stackedChart = new Chart(ctx.getContext('2d'), {
    type: 'bar',
    data: {
      labels,
      datasets: [
        { label: 'Green (G)',  data: greens, backgroundColor: colG, stack: 'stack1' },
        { label: 'Amber (A)',  data: ambers, backgroundColor: colA, stack: 'stack1' },
        { label: 'Red (R)',    data: reds,   backgroundColor: colR, stack: 'stack1' }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: { color: getVar('--text') || undefined },
          grid: { display: false }
        },
        y: {
          stacked: true,
          beginAtZero: true,
          ticks: { color: getVar('--text') || undefined },
        }
      },
      plugins: {
        legend: {
          position: 'top',
          labels: { color: getVar('--text') || undefined }
        },
        tooltip: {
          enabled: true,
          callbacks: {
            // Each segment shows label + count
            label: function(context) {
              const label = context.dataset.label || '';
              const value = context.raw || 0;
              return label + ': ' + value;
            },
            // Footer shows total for that bar
            footer: function(tooltipItems) {
              if (!tooltipItems || !tooltipItems.length) return '';
              const idx = tooltipItems[0].dataIndex;
              const total = (greens[idx] || 0) + (ambers[idx] || 0) + (reds[idx] || 0);
              return 'Total: ' + total;
            }
          },
          // consistent styling with theme
          bodyColor: getVar('--text') || undefined,
          titleColor: getVar('--text') || undefined,
          footerColor: getVar('--muted') || undefined
        }
      },
      interaction: { mode: 'index', intersect: false }
    }
  });
}
